#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
多线程异步删除node_modules文件夹内容
支持Windows和Unix系统
"""

import shutil
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
import argparse
import sys


class NodeModulesDeleter:
    def __init__(self, target_path, max_workers=8, chunk_size=100):
        """
        初始化删除器

        Args:
            target_path (str): 要删除的文件夹路径
            max_workers (int): 最大线程数
            chunk_size (int): 每个线程处理的文件数量
        """
        self.target_path = Path(target_path)
        self.max_workers = max_workers
        self.chunk_size = chunk_size
        self.deleted_files = 0
        self.deleted_dirs = 0
        self.failed_items = []
        self.lock = threading.Lock()

    def delete_file(self, file_path):
        """删除单个文件"""
        try:
            if file_path.exists():
                file_path.unlink()
                with self.lock:
                    self.deleted_files += 1
                return True, str(file_path)
        except Exception as e:
            with self.lock:
                self.failed_items.append((str(file_path), str(e)))
            return False, str(file_path)

    def delete_directory(self, dir_path):
        """删除单个目录"""
        try:
            if dir_path.exists():
                shutil.rmtree(dir_path, ignore_errors=True)
                with self.lock:
                    self.deleted_dirs += 1
                return True, str(dir_path)
        except Exception as e:
            with self.lock:
                self.failed_items.append((str(dir_path), str(e)))
            return False, str(dir_path)

    def get_all_items(self):
        """获取所有文件和目录"""
        items = []
        if not self.target_path.exists():
            return items

        try:
            for item in self.target_path.rglob("*"):
                items.append(item)
        except Exception as e:
            print(f"遍历目录时出错: {e}")

        return items

    def chunk_items(self, items):
        """将项目分块"""
        for i in range(0, len(items), self.chunk_size):
            yield items[i : i + self.chunk_size]

    def delete_chunk(self, chunk):
        """删除一个块中的项目"""
        for item in chunk:
            if item.is_file():
                self.delete_file(item)
            else:
                self.delete_directory(item)

    def delete_all(self):
        """执行删除操作"""
        print(f"开始删除: {self.target_path}")
        print(f"使用 {self.max_workers} 个线程")

        # 获取所有项目
        items = self.get_all_items()
        if not items:
            print("目录为空或不存在")
            return

        print(f"找到 {len(items)} 个项目")

        # 分块处理
        chunks = list(self.chunk_items(items))
        print(f"分为 {len(chunks)} 个块处理")

        start_time = time.time()

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # 提交所有任务
            future_to_chunk = {
                executor.submit(self.delete_chunk, chunk): i
                for i, chunk in enumerate(chunks)
            }

            # 处理完成的任务
            completed = 0
            for future in as_completed(future_to_chunk):
                chunk_index = future_to_chunk[future]
                try:
                    future.result()
                    completed += 1
                    print(f"完成块 {chunk_index + 1}/{len(chunks)}")
                except Exception as e:
                    print(f"块 {chunk_index + 1} 处理失败: {e}")

        end_time = time.time()

        # 尝试删除根目录
        try:
            if self.target_path.exists():
                shutil.rmtree(self.target_path, ignore_errors=True)
                print(f"删除根目录: {self.target_path}")
        except Exception as e:
            print(f"删除根目录失败: {e}")

        # 输出统计信息
        print("\n" + "=" * 50)
        print("删除完成!")
        print(f"删除的文件数: {self.deleted_files}")
        print(f"删除的目录数: {self.deleted_dirs}")
        print(f"失败的项目数: {len(self.failed_items)}")
        print(f"总耗时: {end_time - start_time:.2f} 秒")

        if self.failed_items:
            print("\n失败的项目:")
            for path, error in self.failed_items[:10]:  # 只显示前10个
                print(f"  {path}: {error}")
            if len(self.failed_items) > 10:
                print(f"  ... 还有 {len(self.failed_items) - 10} 个失败项目")


def main():
    parser = argparse.ArgumentParser(description="多线程异步删除node_modules文件夹")
    default_path = "F:\\Repositories\\Happy-TTS\\frontend\\docs\\node_modules"
    parser.add_argument(
        "path",
        nargs="?",
        default=default_path,
        help=f"要删除的文件夹路径 (默认: {default_path})",
    )
    parser.add_argument(
        "--workers", "-w", type=int, default=8, help="最大线程数 (默认: 8)"
    )
    parser.add_argument(
        "--chunk-size",
        "-c",
        type=int,
        default=100,
        help="每个线程处理的文件数量 (默认: 100)",
    )
    parser.add_argument("--confirm", "-y", action="store_true", help="跳过确认提示")

    args = parser.parse_args()

    target_path = Path(args.path)

    if not target_path.exists():
        print(f"错误: 路径不存在 {target_path}")
        sys.exit(1)

    if not args.confirm:
        print(f"即将删除: {target_path}")
        print("警告: 此操作不可逆!")
        response = input("确认删除? (y/N): ")
        if response.lower() != "y":
            print("操作已取消")
            sys.exit(0)

    deleter = NodeModulesDeleter(
        target_path=target_path, max_workers=args.workers, chunk_size=args.chunk_size
    )

    try:
        deleter.delete_all()
    except KeyboardInterrupt:
        print("\n操作被用户中断")
        sys.exit(1)
    except Exception as e:
        print(f"删除过程中出错: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
